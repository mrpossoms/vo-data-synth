#include <g.h>

#include <algorithm>
#include <set>

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#define GL_GLEXT_PROTOTYPES
#define EGL_EGLEXT_PROTOTYPES
#endif

using mat4 = xmath::mat<4,4>;

float saturate(float x)
{
    return std::min<float>(1.f, std::max<float>(0, x));
}

float clamp(float x, float h, float l)
{
    return std::min<float>(h, std::max<float>(l, x));
}

struct my_core : public g::core
{
    g::gfx::shader basic_shader;
    g::asset::store assets;
    g::game::fps_camera cam;
    std::vector<int8_t> v[3];

    g::gfx::density_volume<g::gfx::vertex::pos_norm_tan>* terrain;

    g::game::sdf terrain_sdf;

    virtual bool initialize()
    {
        std::cout << "initialize your game state here.\n";

        srand(time(NULL));

        { // generate some entropy for use in the perlin noise functions
            std::default_random_engine generator;
            std::uniform_int_distribution<int> distribution(-127,128);
            for (unsigned i = 2048; i--;)
            {
                v[0].push_back(distribution(generator));
                v[1].push_back(distribution(generator));
                v[2].push_back(distribution(generator));
            }
        }

        // sdf describing the surface of the terrain to render and collide against
        terrain_sdf = [&](const vec<3>& p) -> float {
            auto r = sqrtf(p.dot(p));
            auto d = r - 1000.f;

            d += g::gfx::noise::perlin(p*0.065, v[0]);
            d += std::min<float>(0, g::gfx::noise::perlin(p*0.0234, v[1]) * 40);
            d += g::gfx::noise::perlin(p*0.0123, v[2]) * 80;

            return d;
        };

        // function for emitting a single vertex given a position and the sdf defined above
        auto generator = [](const g::game::sdf& sdf, const vec<3>& pos) -> g::gfx::vertex::pos_norm_tan
        {
            g::gfx::vertex::pos_norm_tan v;

            const float s = 1;
            v.normal = normal_from_sdf(sdf, pos, s);
            v.position = pos;

            if (fabs(v.normal.dot({0, 1, 0})) > 0.999f)
            {
                v.tangent = vec<3>::cross(v.normal, {1, 0, 0});
            }
            else
            {
                v.tangent = vec<3>::cross(v.normal, {0, 1, 0});   
            }
        
            return v;
        };

        // define a list of integer offsets which describe the relative positioning
        // of the blocks of terrain which will be generated by the density_volume instance below
        std::vector<vec<3>> offsets;
        auto k = 1;
        for (float x = -k; x <= k; x++)
        for (float y = -k; y <= k; y++)
        for (float z = -k; z <= k; z++)
        {
            offsets.push_back({x, y, z});
        }

        // setup the density_volume instance which will be responsible for terrain generation
        terrain = new g::gfx::density_volume<g::gfx::vertex::pos_norm_tan>(terrain_sdf, generator, offsets);
        terrain->scale = 200; // size of each block in world units
        terrain->depth = 4; // resolution of terrain blocks

        // Position the camera, define the player's height
        cam.position = { 0, 1100, 0 };
        cam.foot_offset = { 0, -1.5, 0 };

        // Setup camera input
        cam.on_input = [](fps_camera& cam, float dt){
            static double xlast, ylast;
            float sensitivity = 0.5f;
            double xpos = 0, ypos = 0;
            auto mode = glfwGetInputMode(g::gfx::GLFW_WIN, GLFW_CURSOR);

            if (GLFW_CURSOR_DISABLED == mode)
            {
                glfwGetCursorPos(g::gfx::GLFW_WIN, &xpos, &ypos);
            }

            if (glfwGetInputMode(g::gfx::GLFW_WIN, GLFW_CURSOR) == GLFW_CURSOR_DISABLED)
            if (xlast != 0 || ylast != 0)
            {
                auto dx = xpos - xlast;
                auto dy = ypos - ylast;
                cam.pitch += (dy * dt * sensitivity);
                cam.yaw += (-dx * dt * sensitivity);
            }

            xlast = xpos; ylast = ypos;

            auto speed = cam.speed;
            speed *= cam.touching_surface ? 1 : 0.1;
            if (glfwGetKey(g::gfx::GLFW_WIN, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS) speed *= (cam.touching_surface ? 5 : 1);
            if (glfwGetKey(g::gfx::GLFW_WIN, GLFW_KEY_W) == GLFW_PRESS) cam.velocity += cam.body_forward() * speed;
            if (glfwGetKey(g::gfx::GLFW_WIN, GLFW_KEY_S) == GLFW_PRESS) cam.velocity += cam.body_forward() * -speed;
            if (glfwGetKey(g::gfx::GLFW_WIN, GLFW_KEY_A) == GLFW_PRESS) cam.velocity += cam.body_left() * speed;
            if (glfwGetKey(g::gfx::GLFW_WIN, GLFW_KEY_D) == GLFW_PRESS) cam.velocity += cam.body_left() * -speed;
            if (glfwGetKey(g::gfx::GLFW_WIN, GLFW_KEY_SPACE) == GLFW_PRESS) cam.velocity += cam.body_up() * 5 * cam.touching_surface;
            if (glfwGetKey(g::gfx::GLFW_WIN, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetInputMode(g::gfx::GLFW_WIN, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
        
            if (glfwGetMouseButton(g::gfx::GLFW_WIN, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS)
            {
                glfwSetInputMode(g::gfx::GLFW_WIN, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
            }
        };

        glfwSetInputMode(g::gfx::GLFW_WIN, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

        return true;
    }

    virtual void update(float dt)
    {
        glClearColor(0.5, 0.5, 1, 1);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // define the collider for the terrain
        g::dyn::cd::sdf_collider ground_collider(terrain_sdf);

        // update the camera's direction of gravity. This will influence the direction the
        // that is 'up' from the camera's perspective. This isn't strictly required for a flat
        // world. But for a spherical one, our percieved direction of gravity changes as the camera
        // traverses the surface.
        vec<3> down = -cam.position.unit();
        cam.gravity = down * 9.8;

        // process input and update the velocities.
        cam.pre_update(dt, 0);
        cam.aspect_ratio(g::gfx::aspect());

        // compute intersections. This tells the camera if it's touching a surface and used for
        // collision resolution in the next step
        auto intersections = cam.intersections(ground_collider, 1);
        cam.touching_surface = intersections.size() > 0;

        // resolve collisions. This modifies velocities so that the camera will not penetrate
        // the surface we are colliding with (ground).
        if (cam.touching_surface)
        {
            g::dyn::cr::resolve_linear<fps_camera>(cam, intersections);
        }

        // after velocities have been corrected, update the camera's position
        cam.update(dt, 0);

        // allow the terrain to generate more blocks if needed
        terrain->update(cam);


        // grab textures for terrain
        auto& wall = assets.tex("rock_wall.repeating.png");
        auto& ground = assets.tex("sand.repeating.png");
        auto& wall_normal = assets.tex("rock_wall_normal.repeating.png");
        auto& ground_normal = assets.tex("sand_normal.repeating.png");
        auto model = mat4::I();

        // draw terrain
        terrain->draw(cam, assets.shader("planet.vs+planet_color.fs"), [&](g::gfx::shader::usage& usage) {
            // this allows the user to set shader uniforms for each block before it's drawn
            usage["u_wall"].texture(wall)
                 ["u_ground"].texture(ground)
                 ["u_wall_normal"].texture(wall_normal)
                 ["u_ground_normal"].texture(ground_normal)
                 ["u_model"].mat4(model)
                 ["u_time"].flt(t += dt * 0.01f);
        });
    
    }

    float t;
};

my_core core;

int main (int argc, const char* argv[])
{
    core.start({ 
        .name = argv[0],
        .gfx = {
            .display = true,
            .width = 512,
            .height = 512 
        }
    });

    return 0;
}
